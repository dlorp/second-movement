#!/usr/bin/env python3
"""
generate_config.py - Generate movement_config.h for a custom firmware build.

Called by the custom-build GitHub Actions workflow. Writes a movement_config.h
that covers all defines present in the canonical movement_config.h.
"""

import argparse
import json
import os
import re
import sys


REGISTRY_PATH = "builder/face_registry.json"

# Allowlist of valid signal tune defines from movement_custom_signal_tunes.h.
VALID_SIGNAL_TUNES = {
    'SIGNAL_TUNE_DEFAULT',
    'SIGNAL_TUNE_EVANGELION',
    'SIGNAL_TUNE_HARRY_POTTER_LONG',
    'SIGNAL_TUNE_HARRY_POTTER_SHORT',
    'SIGNAL_TUNE_JURASSIC_PARK',
    'SIGNAL_TUNE_KIM_POSSIBLE',
    'SIGNAL_TUNE_LAYLA',
    'SIGNAL_TUNE_MARIO_THEME',
    'SIGNAL_TUNE_MGS_CODEC',
    'SIGNAL_TUNE_POWER_RANGERS',
    'SIGNAL_TUNE_ZELDA_SECRET',
}

DEFAULTS_TEMPLATE = """\
// movement_defaults.h - Auto-generated by custom build workflow - do not edit
// First-boot runtime defaults for BKUP register initialization.
#ifndef MOVEMENT_DEFAULTS_H_
#define MOVEMENT_DEFAULTS_H_

#define MOVEMENT_DEFAULT_LATITUDE 0
#define MOVEMENT_DEFAULT_LONGITUDE 0
#define MOVEMENT_DEFAULT_ACTIVE_HOURS_START {active_hours_start}
#define MOVEMENT_DEFAULT_ACTIVE_HOURS_END {active_hours_end}
#define MOVEMENT_DEFAULT_ACTIVE_HOURS_ENABLED {active_hours_enabled_c}

#endif // MOVEMENT_DEFAULTS_H_
"""

TEMPLATE = """\
/*
 * Auto-generated by custom build workflow - do not edit.
 */

#ifndef MOVEMENT_CONFIG_H_
#define MOVEMENT_CONFIG_H_

#include "movement_faces.h"

{phase_engine_define}
const watch_face_t watch_faces[] = {{
{face_list}
}};

#define MOVEMENT_NUM_FACES (sizeof(watch_faces) / sizeof(watch_face_t))

/* Determines what face to go to from the first face on long press of the Mode
 * button. Also excludes these faces from the normal rotation.
 * Set to 0 to disable the long-press shortcut.
 */
#define MOVEMENT_SECONDARY_FACE_INDEX {secondary_index}

/* Custom hourly chime tune. Check movement_custom_signal_tunes.h for options. */
#define {signal_tune}

/* Determines the intensity of the led colors.
 * Set a value 0-15 with 0 being off and 15 being max intensity.
 */
#define MOVEMENT_DEFAULT_RED_COLOR {led_red_hex}
#define MOVEMENT_DEFAULT_GREEN_COLOR {led_green_hex}
#define MOVEMENT_DEFAULT_BLUE_COLOR {led_blue_hex}

/* Set to true for 24h mode or false for 12h mode */
#define MOVEMENT_DEFAULT_24H_MODE {clock_24h_bool}

/* Enable or disable the sound on mode button press */
#define MOVEMENT_DEFAULT_BUTTON_SOUND {button_sound_bool}

#define MOVEMENT_DEFAULT_BUTTON_VOLUME WATCH_BUZZER_VOLUME_SOFT
#define MOVEMENT_DEFAULT_SIGNAL_VOLUME WATCH_BUZZER_VOLUME_LOUD
#define MOVEMENT_DEFAULT_ALARM_VOLUME WATCH_BUZZER_VOLUME_LOUD

/* Set the timeout before switching back to the main watch face
 * Valid values are:
 * 0: 60 seconds
 * 1: 2 minutes
 * 2: 5 minutes
 * 3: 30 minutes
 */
#define MOVEMENT_DEFAULT_TIMEOUT_INTERVAL 0

/* Set the timeout before switching to low energy mode
 * Valid values are:
 * 0: Never
 * 1: 10 minutes
 * 2: 1 hour
 * 3: 2 hours
 * 4: 6 hours
 * 5: 12 hours
 * 6: 1 day
 * 7: 7 days
 */
#define MOVEMENT_DEFAULT_LOW_ENERGY_INTERVAL 2

/* Set the led duration
 * Valid values are:
 * 0: No LED
 * 1: 1 second
 * 2: 3 seconds
 * 3: 5 seconds
 */
#define MOVEMENT_DEFAULT_LED_DURATION 1

/* Optionally debounce button presses (disable by default).
 * A value of 4 is a good starting point if you have issues
 * with multiple button presses firing.
 */
#define MOVEMENT_DEBOUNCE_TICKS 0

#endif /* MOVEMENT_CONFIG_H_ */
"""

# Pattern for valid face IDs: lowercase C identifier
FACE_ID_RE = re.compile(r'^[a-z_][a-z0-9_]*$')

# Pattern for valid signal tune values: uppercase C identifier
SIGNAL_TUNE_RE = re.compile(r'^[A-Z_][A-Z0-9_]*$')


def validate_face_id(face_id):
    """
    Validate that face_id is a safe lowercase C identifier.
    Raises ValueError if invalid.
    """
    if not FACE_ID_RE.match(face_id):
        raise ValueError(
            "Invalid face ID {!r}: must match ^[a-z_][a-z0-9_]*$".format(face_id)
        )
    return face_id


def validate_signal_tune(value):
    """
    Validate signal_tune against a format check and an allowlist.
    Raises ValueError if the value is not a known, safe tune identifier.
    """
    if not SIGNAL_TUNE_RE.match(value):
        raise ValueError(
            "Invalid signal_tune {!r}: must match ^[A-Z_][A-Z0-9_]*$".format(value)
        )
    if value not in VALID_SIGNAL_TUNES:
        raise ValueError(
            "Unknown signal_tune {!r}. Valid options: {}".format(
                value, sorted(VALID_SIGNAL_TUNES)
            )
        )
    return value


def load_registry(registry_path):
    """Load face registry from JSON. Returns None and warns if not found."""
    if not os.path.isfile(registry_path):
        print(
            "WARNING: face registry not found at '{}'. "
            "Face validation will be skipped.".format(registry_path),
            file=sys.stderr,
        )
        return None
    with open(registry_path, "r") as f:
        return json.load(f)


def validate_face(face_id, registry):
    """Return True if face_id is valid according to the registry."""
    if registry is None:
        return True
    faces = registry.get("faces", registry)
    # faces is a list of dicts, check if face_id is in any dict's 'id' field
    if isinstance(faces, list):
        return any(f.get("id") == face_id for f in faces)
    # fallback for old registry format (dict of face_id: face_data)
    return face_id in faces


def find_face_source(face_id, watch_faces_root="watch-faces"):
    """
    Find the .c file for a given face ID by scanning the watch-faces tree.
    Returns the relative path string (e.g. 'watch-faces/clock/clock_face.c')
    or None if not found.
    """
    for category in os.listdir(watch_faces_root):
        candidate = os.path.join(watch_faces_root, category, face_id + ".c")
        if os.path.isfile(candidate):
            return candidate
    return None


def int_to_hex(value):
    """Convert an integer 0-15 to a C hex literal (0x0 - 0xF)."""
    return "0x{:X}".format(value)


def parse_bool(value):
    """Parse a boolean-like string to a Python bool."""
    if isinstance(value, bool):
        return value
    return str(value).strip().lower() in ("true", "1", "yes")


def validate_quarter_hours(value, name):
    try:
        v = int(value)
    except ValueError:
        raise ValueError("{} must be an integer, got {!r}".format(name, value))
    if v < 0 or v > 95:
        raise ValueError("{} must be 0-95, got {}".format(name, v))
    return v


def main():
    parser = argparse.ArgumentParser(
        description="Generate movement_config.h for a custom firmware build."
    )
    parser.add_argument(
        "--faces",
        required=True,
        help="Comma-separated list of face IDs.",
    )
    parser.add_argument(
        "--secondary-index",
        default="0",
        help="Value for MOVEMENT_SECONDARY_FACE_INDEX.",
    )
    parser.add_argument(
        "--clock-24h",
        default="false",
        help="Enable 24h mode by default (true/false).",
    )
    parser.add_argument(
        "--led-red",
        default="0",
        help="Default LED red intensity (0-15).",
    )
    parser.add_argument(
        "--led-green",
        default="15",
        help="Default LED green intensity (0-15).",
    )
    parser.add_argument(
        "--led-blue",
        default="0",
        help="Default LED blue intensity (0-15).",
    )
    parser.add_argument(
        "--button-sound",
        default="true",
        help="Enable button click sound by default (true/false).",
    )
    parser.add_argument(
        "--signal-tune",
        default="SIGNAL_TUNE_DEFAULT",
        help="Signal tune define name (e.g. SIGNAL_TUNE_DEFAULT).",
    )
    parser.add_argument(
        "--active-hours-start",
        default="16",
        help="Active hours start, quarter-hours 0-95 (default 16 = 04:00).",
    )
    parser.add_argument(
        "--active-hours-end",
        default="92",
        help="Active hours end, quarter-hours 0-95 (default 92 = 23:00).",
    )
    parser.add_argument(
        "--active-hours-enabled",
        default="true",
        help="Active hours enabled first-boot default (true/false).",
    )
    parser.add_argument(
        "--phase-engine",
        default="false",
        help="Enable phase engine (true/false).",
    )
    parser.add_argument(
        "--output",
        default="movement_config.h",
        help="Output file path.",
    )
    parser.add_argument(
        "--defaults-output",
        default=None,
        help="Output path for movement_defaults.h (default: same dir as --output).",
    )
    parser.add_argument(
        "--registry",
        default=REGISTRY_PATH,
        help="Path to face_registry.json.",
    )

    args = parser.parse_args()

    # Parse face list and validate each ID is a safe C identifier
    face_ids_raw = [f.strip() for f in args.faces.split(",") if f.strip()]
    if not face_ids_raw:
        print("ERROR: --faces must not be empty.", file=sys.stderr)
        sys.exit(1)

    face_ids = []
    for raw_id in face_ids_raw:
        try:
            face_ids.append(validate_face_id(raw_id))
        except ValueError as exc:
            print("ERROR: {}".format(exc), file=sys.stderr)
            sys.exit(1)

    # Validate signal_tune against allowlist
    try:
        signal_tune = validate_signal_tune(args.signal_tune)
    except ValueError as exc:
        print("ERROR: {}".format(exc), file=sys.stderr)
        sys.exit(1)

    # Load and validate against registry
    registry = load_registry(args.registry)
    unknown = []
    for face_id in face_ids:
        if not validate_face(face_id, registry):
            unknown.append(face_id)
    if unknown:
        print(
            "ERROR: Unknown face IDs: {}".format(", ".join(unknown)),
            file=sys.stderr,
        )
        sys.exit(1)

    # Build face list for the C array
    face_list_lines = []
    for face_id in face_ids:
        face_list_lines.append("    {},".format(face_id))
    # Strip trailing comma from last entry
    if face_list_lines:
        face_list_lines[-1] = face_list_lines[-1].rstrip(",")
    face_list = "\n".join(face_list_lines)

    # Parse and validate numeric/boolean inputs
    try:
        secondary_index = int(args.secondary_index)
    except ValueError:
        print(
            "ERROR: --secondary-index must be an integer, got '{}'.".format(
                args.secondary_index
            ),
            file=sys.stderr,
        )
        sys.exit(1)

    try:
        led_red = int(args.led_red)
        led_green = int(args.led_green)
        led_blue = int(args.led_blue)
    except ValueError as exc:
        print("ERROR: LED intensity values must be integers. {}".format(exc), file=sys.stderr)
        sys.exit(1)

    for name, val in (("led_red", led_red), ("led_green", led_green), ("led_blue", led_blue)):
        if not 0 <= val <= 15:
            print(
                "ERROR: --{} must be in range 0-15, got {}.".format(name, val),
                file=sys.stderr,
            )
            sys.exit(1)

    clock_24h = parse_bool(args.clock_24h)
    button_sound = parse_bool(args.button_sound)

    # Validate active hours inputs
    try:
        active_hours_start = validate_quarter_hours(args.active_hours_start, "--active-hours-start")
    except ValueError as exc:
        print("ERROR: {}".format(exc), file=sys.stderr)
        sys.exit(1)

    try:
        active_hours_end = validate_quarter_hours(args.active_hours_end, "--active-hours-end")
    except ValueError as exc:
        print("ERROR: {}".format(exc), file=sys.stderr)
        sys.exit(1)

    active_hours_enabled = parse_bool(args.active_hours_enabled)
    phase_engine_enabled = parse_bool(args.phase_engine)

    # Generate phase engine define if enabled
    phase_engine_define = ""
    if phase_engine_enabled:
        phase_engine_define = "#define PHASE_ENGINE_ENABLED\n"

    # Render template
    output = TEMPLATE.format(
        phase_engine_define=phase_engine_define,
        face_list=face_list,
        secondary_index=secondary_index,
        signal_tune=signal_tune,
        led_red_hex=int_to_hex(led_red),
        led_green_hex=int_to_hex(led_green),
        led_blue_hex=int_to_hex(led_blue),
        clock_24h_bool="true" if clock_24h else "false",
        button_sound_bool="true" if button_sound else "false",
    )

    with open(args.output, "w") as f:
        f.write(output)

    print("Wrote {} ({} faces)".format(args.output, len(face_ids)))

    # Determine defaults output path
    if args.defaults_output is not None:
        defaults_output_path = args.defaults_output
    else:
        defaults_output_path = os.path.join(
            os.path.dirname(os.path.abspath(args.output)),
            "movement_defaults.h",
        )

    defaults_output = DEFAULTS_TEMPLATE.format(
        active_hours_start=active_hours_start,
        active_hours_end=active_hours_end,
        active_hours_enabled_c="true" if active_hours_enabled else "false",
    )

    with open(defaults_output_path, "w") as f:
        f.write(defaults_output)

    print("Wrote {}".format(defaults_output_path))


if __name__ == "__main__":
    main()

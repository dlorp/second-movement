#!/usr/bin/env python3
"""
generate_watchfaces_mk.py - Generate watch-faces.mk for a custom firmware build.

Called by the custom-build GitHub Actions workflow. Produces a watch-faces.mk
containing only the source files needed for the requested face set.
"""

import argparse
import json
import os
import re
import sys


WATCH_FACES_ROOT = "watch-faces"

HEADER = "# Auto-generated by custom build workflow - do not edit.\n"

# Pattern for valid face IDs: lowercase C identifier
FACE_ID_RE = re.compile(r'^[a-z_][a-z0-9_]*$')


def validate_face_id(face_id):
    """
    Validate that face_id is a safe lowercase C identifier.
    Raises ValueError if invalid.
    """
    if not FACE_ID_RE.match(face_id):
        raise ValueError(
            "Invalid face ID {!r}: must match ^[a-z_][a-z0-9_]*$".format(face_id)
        )
    return face_id


def load_registry(registry_path):
    """
    Load face registry from JSON. Returns None and emits a warning if not found.
    Expected registry format:
      {
        "faces": {
          "clock_face": { "path": "watch-faces/clock/clock_face.c", ... },
          ...
        }
      }
    The top-level key "faces" is optional; the root object may directly map IDs
    to face metadata objects.
    """
    if not os.path.isfile(registry_path):
        print(
            "WARNING: face registry not found at '{}'. "
            "Falling back to filesystem search.".format(registry_path),
            file=sys.stderr,
        )
        return None
    with open(registry_path, "r") as f:
        data = json.load(f)
    # Support both {faces: {id: ...}} and {id: ...} top-level formats
    if "faces" in data and isinstance(data["faces"], dict):
        return data["faces"]
    return data


def find_face_source(face_id, watch_faces_root=WATCH_FACES_ROOT):
    """
    Locate the .c source file for a face ID by scanning the watch-faces tree.
    Returns the path relative to the repo root (e.g. ./watch-faces/clock/clock_face.c),
    or None if not found.
    """
    if not os.path.isdir(watch_faces_root):
        return None
    for category in sorted(os.listdir(watch_faces_root)):
        candidate = os.path.join(watch_faces_root, category, face_id + ".c")
        if os.path.isfile(candidate):
            # Normalise to the format used in the existing watch-faces.mk
            return "./" + candidate.replace(os.sep, "/")
    return None


def resolve_face_path(face_id, registry):
    """
    Return the makefile source path for a face ID.
    Tries the registry first, falls back to filesystem search.
    Returns None if the face cannot be located.
    """
    if registry is not None and face_id in registry:
        entry = registry[face_id]
        # Registry entries may store the path under key "path" or "source"
        raw = entry.get("path") or entry.get("source", "")
        if raw:
            # Ensure leading ./ prefix for consistency
            if not raw.startswith("./"):
                raw = "./" + raw
            return raw

    # Fallback: search filesystem
    return find_face_source(face_id)


def main():
    parser = argparse.ArgumentParser(
        description="Generate watch-faces.mk for a custom firmware build."
    )
    parser.add_argument(
        "--faces",
        required=True,
        help="Comma-separated list of face IDs.",
    )
    parser.add_argument(
        "--registry",
        default="builder/face_registry.json",
        help="Path to face_registry.json.",
    )
    parser.add_argument(
        "--output",
        default="watch-faces.mk",
        help="Output file path.",
    )

    args = parser.parse_args()

    face_ids_raw = [f.strip() for f in args.faces.split(",") if f.strip()]
    if not face_ids_raw:
        print("ERROR: --faces must not be empty.", file=sys.stderr)
        sys.exit(1)

    # Validate all face IDs are safe C identifiers before any further processing
    face_ids = []
    for raw_id in face_ids_raw:
        try:
            face_ids.append(validate_face_id(raw_id))
        except ValueError as exc:
            print("ERROR: {}".format(exc), file=sys.stderr)
            sys.exit(1)

    registry = load_registry(args.registry)

    lines = [HEADER]
    missing = []

    for face_id in face_ids:
        path = resolve_face_path(face_id, registry)
        if path is None:
            missing.append(face_id)
            print(
                "ERROR: Could not locate source file for face '{}'.".format(face_id),
                file=sys.stderr,
            )
        else:
            lines.append("SRCS += {}\n".format(path))

    if missing:
        print(
            "ERROR: Missing source files for: {}".format(", ".join(missing)),
            file=sys.stderr,
        )
        sys.exit(1)

    output_content = "".join(lines)

    with open(args.output, "w") as f:
        f.write(output_content)

    print("Wrote {} ({} faces)".format(args.output, len(face_ids)))


if __name__ == "__main__":
    main()
